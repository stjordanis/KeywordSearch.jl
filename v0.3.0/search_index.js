var documenterSearchIndex = {"docs":
[{"location":"api_documentation/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api_documentation/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = KeywordSearch","category":"page"},{"location":"api_documentation/#Queries","page":"API Documentation","title":"Queries","text":"","category":"section"},{"location":"api_documentation/","page":"API Documentation","title":"API Documentation","text":"Query\nFuzzyQuery\nNamedQuery","category":"page"},{"location":"api_documentation/#KeywordSearch.Query","page":"API Documentation","title":"KeywordSearch.Query","text":"Query <: AbstractQuery\n\nA query to search for an exact match of a string, with one field:\n\ntext::String\n\nThe text is automatically processed by applying the replacements from AUTOMATIC_REPLACEMENTS.\n\n\n\n\n\n","category":"type"},{"location":"api_documentation/#KeywordSearch.FuzzyQuery","page":"API Documentation","title":"KeywordSearch.FuzzyQuery","text":"FuzzyQuery{D,T} <: AbstractQuery\n\nA query to search for an fuzzy match of a string, with three fields:\n\ntext::String: the text to match\ndist::D: the distance measure to use; defaults to DamerauLevenshtein()\nthreshold::T: the maximum threshold allowed for a match; defaults to 2.\n\nThe text is automatically processed by applying the replacements from AUTOMATIC_REPLACEMENTS.\n\n\n\n\n\n","category":"type"},{"location":"api_documentation/#KeywordSearch.NamedQuery","page":"API Documentation","title":"KeywordSearch.NamedQuery","text":"NamedQuery(metadata::Union{String, NamedTuple}, query::AbstractQuery)\n\nCreates a NamedQuery that stores a metadata field holding information about the query. When used with match, returns a NamedMatch, which carries the metadata of the NamedQuery as well as the metadata of the object which was matched.\n\nExample\n\njulia> document_1 = Document(\"One\", (; document_name = \"a\"))\nDocument with text \"One \". Metadata: (document_name = \"a\",)\n\njulia> document_2 = Document(\"Two\", (; document_name = \"b\"))\nDocument with text \"Two \". Metadata: (document_name = \"b\",)\n\njulia> corpus = Corpus([document_1, document_2], (; corpus_name = \"Numbers\"))\nCorpus with 2 documents, each with metadata keys: (:document_name,)\nCorpus metadata: (corpus_name = \"Numbers\",)\n\njulia> query = NamedQuery(FuzzyQuery(\"one\"), \"find one\")\nNamedQuery\n├─ (query_name = \"find one\",)\n└─ FuzzyQuery(\"one\", DamerauLevenshtein{Nothing}(nothing), 2)\n\njulia> m = match(query, corpus)\nNamedMatch\n├─ (query_name = \"find one\", corpus_name = \"Numbers\", document_name = \"a\")\n└─ QueryMatch with distance 1 at indices 1:3.\n   ├─ FuzzyQuery(\"one\", DamerauLevenshtein{Nothing}(nothing), 2)\n   └─ Document with text \"One \". Metadata: (document_name = \"a\",)\n\njulia> m.metadata\n(query_name = \"find one\", corpus_name = \"Numbers\", document_name = \"a\")\n\n\n\n\n\n","category":"type"},{"location":"api_documentation/#Documents","page":"API Documentation","title":"Documents","text":"","category":"section"},{"location":"api_documentation/","page":"API Documentation","title":"API Documentation","text":"Document\nmatch(::AbstractQuery, ::Document)\nmatch_all(::AbstractQuery, ::Document)","category":"page"},{"location":"api_documentation/#KeywordSearch.Document","page":"API Documentation","title":"KeywordSearch.Document","text":"Document{T<:NamedTuple}\n\nRepresents a single string document. This object has two fields,\n\ntext::String\nmetadata::T\n\nThe text is automatically processed by applying the replacements from AUTOMATIC_REPLACEMENTS and adding a space to the end of the document.\n\n\n\n\n\n","category":"type"},{"location":"api_documentation/#Base.match-Tuple{KeywordSearch.AbstractQuery,Document}","page":"API Documentation","title":"Base.match","text":"Base.match(query::AbstractQuery, document::Document)\n\nLooks for a match for query in document. Returns either nothing if no match is found, or a QueryMatch object.\n\n\n\n\n\n","category":"method"},{"location":"api_documentation/#KeywordSearch.match_all-Tuple{KeywordSearch.AbstractQuery,Document}","page":"API Documentation","title":"KeywordSearch.match_all","text":"match_all(query::AbstractQuery, document::Document)\n\nLooks for all matches for query in the document. Returns a Vector QueryMatch objects corresponding to all of the matches found.\n\n\n\n\n\n","category":"method"},{"location":"api_documentation/#Corpuses","page":"API Documentation","title":"Corpuses","text":"","category":"section"},{"location":"api_documentation/","page":"API Documentation","title":"API Documentation","text":"Corpus\nmatch(::AbstractQuery, ::Corpus)\nmatch_all(::AbstractQuery, ::Corpus)","category":"page"},{"location":"api_documentation/#KeywordSearch.Corpus","page":"API Documentation","title":"KeywordSearch.Corpus","text":"Corpus{T<:NamedTuple,D}\n\nA corpus is a collection of Documents, along with some metadata. It has two fields,\n\ndocuments::Vector{Document{D}} \nmetadata::T\n\nNote each Document in a Corpus must have metadata of the same type.\n\n\n\n\n\n","category":"type"},{"location":"api_documentation/#Base.match-Tuple{KeywordSearch.AbstractQuery,Corpus}","page":"API Documentation","title":"Base.match","text":"Base.match(query::AbstractQuery, corpus::Corpus)\n\nLooks for a match for query in any Document in corpus. Returns either nothing if no match is found in any Document, or a QueryMatch object.\n\n\n\n\n\n","category":"method"},{"location":"api_documentation/#KeywordSearch.match_all-Tuple{KeywordSearch.AbstractQuery,Corpus}","page":"API Documentation","title":"KeywordSearch.match_all","text":"match_all(query::AbstractQuery, corpus::Corpus)\n\nLooks for all matches for query from all documents in corpus. Returns a Vector of QueryMatch objects corresponding to all of the matches found, across all doucments.\n\n\n\n\n\n","category":"method"},{"location":"api_documentation/#Matches","page":"API Documentation","title":"Matches","text":"","category":"section"},{"location":"api_documentation/","page":"API Documentation","title":"API Documentation","text":"QueryMatch\nNamedMatch","category":"page"},{"location":"api_documentation/#KeywordSearch.QueryMatch","page":"API Documentation","title":"KeywordSearch.QueryMatch","text":"QueryMatch{Q<:AbstractQuery,Doc<:Document,D,I}\n\nRepresents a match for an AbstractQuery, with four fields:\n\nquery::Q: the query itself\ndocument::Doc: the Document which was matched to\ndistance::D: the distance of the match\nindices::I: the indices of where in the document the match occurred.\n\n\n\n\n\n","category":"type"},{"location":"api_documentation/#KeywordSearch.NamedMatch","page":"API Documentation","title":"KeywordSearch.NamedMatch","text":"NamedMatch{T,M<:QueryMatch}\n\nThis object has two fields,\n\nmatch::M, which holds a QueryMatch object corresponding to the match\nand metadata::T, which holds a NamedTuple of metadata.\n\nand is created by the method match(query::NamedQuery, obj).\n\nNamedMatch satisfies the Tables.jl AbstractRow interface. This means that a vector of NamedMatch objects is a valid Tables.jl-compatible table.\n\nExample\n\njulia> document_1 = Document(\"one\", (; document_name = \"a\"))\nDocument with text \"one \". Metadata: (document_name = \"a\",)\n\njulia> document_2 = Document(\"Two but there's also a one here.\", (; document_name = \"b\"))\nDocument starting with \"Two but there's…\". Metadata: (document_name = \"b\",)\n\njulia> query = NamedQuery(Query(\"one\"), \"find one\")\nNamedQuery\n├─ (query_name = \"find one\",)\n└─ Query(\"one\")\n\njulia> matches = match_all(query, Corpus([document_1, document_2], (;corpus_name=\"corpus\")));\n\n\njulia> using Tables\n\n\njulia> Tables.istable(matches)\ntrue\n\njulia> Tables.schema(Tables.rowtable(matches))\nTables.Schema:\n :document       Document{NamedTuple{(:document_name,),Tuple{String}}}\n :distance       Int64\n :indices        UnitRange{Int64}\n :query          Query\n :query_name     String\n :corpus_name    String\n :document_name  String\n\n\n\n\n\n\n","category":"type"},{"location":"api_documentation/#Helper-functions","page":"API Documentation","title":"Helper functions","text":"","category":"section"},{"location":"api_documentation/","page":"API Documentation","title":"API Documentation","text":"explain\naugment\nword_boundary","category":"page"},{"location":"api_documentation/#KeywordSearch.explain","page":"API Documentation","title":"KeywordSearch.explain","text":"explain([io=stdout], match; context=40)\n\nPrints a human-readable explanation of the match and its context in the document in which it was found.\n\nExample\n\njulia> document = Document(\"The crabeating macacue ate a crab.\")\nDocument starting with \"The crabeating macacue…\". Metadata: NamedTuple()\n\njulia> query = augment(FuzzyQuery(\"crab-eating macaque\"))\nOr\n├─ FuzzyQuery(\"crab eating macaque\", DamerauLevenshtein{Nothing}(nothing), 2)\n├─ FuzzyQuery(\"crabeating macaque\", DamerauLevenshtein{Nothing}(nothing), 2)\n├─ FuzzyQuery(\"crab eatingmacaque\", DamerauLevenshtein{Nothing}(nothing), 2)\n└─ FuzzyQuery(\"crabeatingmacaque\", DamerauLevenshtein{Nothing}(nothing), 2)\n\njulia> m = match(query, document)\nQueryMatch with distance 1 at indices 5:22.\n\njulia> explain(m)\nThe query \"crabeating macaque\" matched the text \"The crabeating macacue ate a crab  \" with distance 1.\n\njulia> explain(m; context=5) # tweak the amount of context printed\nThe query \"crabeating macaque\" matched the text \"The crabeating macacue ate…\" with distance 1.\n\njulia> sprint(explain, m) # to get the explanation as a string\n\"The query \\\"crabeating macaque\\\" matched the text \\\"The crabeating macacue ate a crab  \\\" with distance 1.\\n\"\n\njulia> explain(match(Query(\"crab\"), document)) # exact queries print slightly differently\nThe query \"crab\" exactly matched the text \"The crabeating macacue ate a crab  \".\n\njulia> explain(match(NamedQuery(Query(\"crab\"), \"crab query\"), document)) # `NamedQuery`s print the same as their underlying query\nThe query \"crab\" exactly matched the text \"The crabeating macacue ate a crab  \".\n\n\n\n\n\n\n","category":"function"},{"location":"api_documentation/#KeywordSearch.augment","page":"API Documentation","title":"KeywordSearch.augment","text":"augment(term) -> Vector{String}\n\nGiven a term, returns a list of terms which should be treated as synonyms. Currently only supports agumenting (spaces or hyphens) with (spaces, no spaces).\n\nExample\n\njulia> KeywordSearch.augment(\"arctic wolf\")\n2-element Array{String,1}:\n \"arctic wolf\"\n \"arcticwolf\"\n \n\n\n\n\n\n","category":"function"},{"location":"api_documentation/#KeywordSearch.word_boundary","page":"API Documentation","title":"KeywordSearch.word_boundary","text":"word_boundary(Q::AbstractQuery) -> AbstractQuery\n\nEnsures that a word or phrase is not hyphenated or conjoined with the surrounding text.\n\nExample\n\njulia> using Test\n\njulia> query = Query(\"word\")\nQuery(\"word\")\n\njulia> @test match(query, Document(\"This matchesword \")) !== nothing\nTest Passed\n\njulia> @test match(word_boundary(query), Document(\"This matches word.\")) !== nothing\nTest Passed\n\njulia> @test match(word_boundary(query), Document(\"This matches word \")) !== nothing\nTest Passed\n\njulia> @test match(word_boundary(query), Document(\"This matches word\\nNext line\")) !== nothing\nTest Passed\n\njulia> @test match(word_boundary(query), Document(\"This doesn't matchword \")) === nothing\nTest Passed\n\n\n\n\n\n\n","category":"function"},{"location":"api_documentation/#Constants","page":"API Documentation","title":"Constants","text":"","category":"section"},{"location":"api_documentation/","page":"API Documentation","title":"API Documentation","text":"AUTOMATIC_REPLACEMENTS","category":"page"},{"location":"api_documentation/#KeywordSearch.AUTOMATIC_REPLACEMENTS","page":"API Documentation","title":"KeywordSearch.AUTOMATIC_REPLACEMENTS","text":"const AUTOMATIC_REPLACEMENTS::Vector{Pair{Union{Regex,String},String}}\n\nA list of replacements to automatically perform when preprocessing a Document. For example, if KeywordSearch.AUTOMATIC_REPLACEMENTS == [\"a\" => \"b\"], then Document(\"abc\").text == \"bbc\" instead of \"abc\".\n\nBy default, AUTOMATIC_REPLACEMENTS contains only one replacement,\n\nr\"[.!?><\\-\\n\\r\\v\\t\\f]\" => \" \"\n\nwhich replaces certain punctuation characters, whitespace, and newlines with a space. This replacement is needed for word_boundary to work correctly, but you can remove it with empty!(KeywordSearch.AUTOMATIC_REPLACEMENTS) if you wish.\n\nYou an also add other preprocessing directives by push!ing further replacements into KeywordSearch.AUTOMATIC_REPLACEMENTS.\n\n\n\n\n\n","category":"constant"},{"location":"#KeywordSearch.jl","page":"Home","title":"KeywordSearch.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KeywordSearch has two main nouns:","category":"page"},{"location":"","page":"Home","title":"Home","text":"queries, which come in two flavors, Query, which is used for exact matches, and FuzzyQuery which is for fuzzy matches\nand documents, which are strings wrapped in Document objects and can optionally have metadata associated with them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documents may also be collected into a Corpus, which is simply a Vector of Documents with additional metadata. Here, metadata simply refers to any NamedTuple stored in the .metadata field of the object.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Queries are used to search Documents or Corpuss via Base.match or match_all. If no match is found, nothing is returned; otherwise, a KeywordSearch.QueryMatch object is returned which contains details of the match.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Quick-tutorial","page":"Quick tutorial","title":"Quick tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"In this example, we will use some sample text modified from the public domain text Aristotle's History of Animals http://www.gutenberg.org/files/59058/59058-0.txt.","category":"page"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"using KeywordSearch, Random\n\ntext_with_typos = Document(\"\"\"\n    Some animals have fet, others have noone; of the former some have\n    two feet, as mankind and birdsonly; others have four, as the lizard\n    and the dog; others, as the scolopendra and bee, have many feet; but\n    all have their feet in pairs.\n    \"\"\") \n\nfuzzy_query = FuzzyQuery(\"birds only\")\n\nm = match(fuzzy_query, text_with_typos)\n\nexplain(m)","category":"page"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"Here, you'll notice an exact query does not match, since the words \"birds\" and \"only\" have been conjoined:","category":"page"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"exact_query = Query(\"birds only\")\n\nmatch(exact_query, text_with_typos) # nothing, no exact match","category":"page"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"KeywordSearch offers the augment function specifically to address mis-conjoined words:","category":"page"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"augmented_query = augment(exact_query)\n\nm2 = match(augmented_query, text_with_typos) # now it matches\n\nm2.query # which of the two queries in the `Or` matched?","category":"page"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"Here, augment generated an Or query, but we can generate one ourselves:","category":"page"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"dog_or_cat = Query(\"dog\") | Query(\"cat\")\n\nm3 = match(dog_or_cat, text_with_typos)\n\nexplain(m3)","category":"page"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"Note also that FuzzyQuery by default uses the DamerauLevenshtein() distance from StringDistances.jl, and searches for a match within a cutoff of 2 but you can pass it another distance or use another cutoff:","category":"page"},{"location":"tutorial/","page":"Quick tutorial","title":"Quick tutorial","text":"fuzzy_query_2 = FuzzyQuery(\"brid nly\", DamerauLevenshtein(), 4)\nm4 = match(fuzzy_query_2, text_with_typos) \nexplain(m4)","category":"page"},{"location":"named_queries/#Tables-of-matches","page":"Tables of matches","title":"Tables of matches","text":"","category":"section"},{"location":"named_queries/","page":"Tables of matches","title":"Tables of matches","text":"via NamedQuerys.","category":"page"},{"location":"named_queries/","page":"Tables of matches","title":"Tables of matches","text":"using KeywordSearch, Random, DataFrames\n\nqueries = [NamedQuery(FuzzyQuery(\"dog\"), \"find dog\"),\n           NamedQuery(FuzzyQuery(\"cat\"), \"find cat\"),\n           NamedQuery(Query(\"koala\") | FuzzyQuery(\"Opossum\"), \"find marsupial\")]\n\nwords = [\"dg\", \"cat\", \"koala\", \"opposum\"]\ncorpus1 = Corpus([Document(randstring(rand(1:10)) * rand(words) * randstring(rand(1:10)),\n                           (; doc_index=j)) for j in 1:10], (; name=\"docs\"))\n\ncorpus1.documents\n\ncorpus2 = Corpus([Document(randstring(rand(1:10)), (; doc_index=2 * j)) for j in 1:10],\n                 (; name=\"other docs\"))\n\ncorpuses = [corpus1, corpus2]\n\nmatches = [match(named_query, corpus) for named_query in queries for corpus in corpuses];\nfilter!(!isnothing, matches);\nDataFrame(matches)","category":"page"},{"location":"named_queries/","page":"Tables of matches","title":"Tables of matches","text":"We can also make use of Transducers.jl to easily multithread or parallelize across cores via tcollect or dcollect:","category":"page"},{"location":"named_queries/","page":"Tables of matches","title":"Tables of matches","text":"using Transducers\nmatches = tcollect(Filter(!isnothing)(MapSplat(match)(Iterators.product(queries, corpuses))));\nDataFrame(matches)","category":"page"}]
}
